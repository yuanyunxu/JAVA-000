
#作业一
| GC/MEM             | 128M | 512M    | 1G      | 2G      | 4G      | 8G      |
| ------------------ | ---- | ------- | ------- | ------- | ------- | ------- |
| UseSerialGC        | OOM  | 13908.4 | 18831.2 | 17942.7 | 15903.8 | 10634.6 |
| UseParallelGC      | OOM  | 10730.8 | 19241.3 | 21413.5 | 21765.2 | 14347.6 |
| UseConcMarkSweepGC | OOM  | 13729.9 | 18409.2 | 17671.8 | 17331.6 | 16474.6 |
| UseG1GC            | OOM  | 15307.3 | 23348.2 | 23697.0 | 21144.1 | 23816.7 |
串行、并行、CMS都有一个先上升后下降的现象，我们从GC的原理来看，内存越大，需要进行标记和整理的对象就越多，而GC的处理能力有一个上限，在能力范围内，也就是内存较小的时候，它能在较短时间内标记和清理完全；但随着内存增大，超过能力范围，其标记和清除的负担加重，性能就表现出下降的趋势了。
对于G1：
 
|内存|528|928|1328|1728|2128|2528|2928|3328|3728|4128|4528|4928|5328|5728|6128|6528|6928|7328|7728|8128|8528|8928|9328|9728|10128|10528|10928|11328|11728|12128|12528|12928|13328|13728|14128|14528|14928|15328|
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| 数量|1817|25974|27909|25241|23936|22951|21251|21932|21455|22793|21814|22870|22611|2485|25148|24337|24010|25259|25966|25012|24570|23426|23547|24961|24840|25256|25623|25497|23764|23444|24347|24468|22766|24960|2460|24151|24411|22070|

G1的性能是要好于前面三种GC的，均值基本都2万以上；在16G内存范围来看，表现较为稳定和平稳
#作业二
sb -u http://localhost:8088/api/hello -c 20 -N 60

| GC/内存 | 512M | 1G   | 2G   | 4G   | 8G   |
| ------- | ---- | ---- | ---- | ---- | ---- |
| 串行    | 5120 | 4488 | 4696 | 4965 | 4483 |
| 并行    | 5137 | 5289 | 5334 | 5228 | 5081 |
| CMS     | 5083 | 5225 | 5526 | 5131 | 5293 |
| G1      | 5400 | 4947 | 5163 | 5158 | 5050 |

串行GC是不适合Web场景的，越到后面性能越低，但并行、CMS、G1在测试中性能差距不是太大。猜测性能没有提升的原因是GC能应对当前的场景，性能的瓶颈现在是在网络请求处理上。


